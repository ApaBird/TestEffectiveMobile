/*
 * Онлайн библиотека песен
 *
 * тестовое задание
 *
 * API version: 0.0.1
 * Contact: apa.birds@mail.ru
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package server

import (
	"SongServer/postgres"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// @Summary		Добавление песни
// @Tags		song
// @Description	Добавление песни по названию и группе
// @ID			addSong
// @Accept		json
// @Produce		json
// @Param		input	body		InfoAddSong	true	"data"
// @Success		200		{string}	id	"data"
// @Failure		400,422	{string}	http.StatusUnprocessableEntity
// @Failure		500		{string}	http.StatusInternalServerError
// @Router		/song [post]
func AddSong(w http.ResponseWriter, r *http.Request) {

	song := InfoAddSong{}
	if err := json.NewDecoder(r.Body).Decode(&song); err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}

	if song.Group == "" || song.Song == "" {
		DebugLogger(w, r, fmt.Errorf("validation exception"), http.StatusUnprocessableEntity)
	}

	songInfo, err := RequestSong(song.Group, song.Song)
	if err != nil {
		DebugLogger(w, r, err, http.StatusNotFound)
	}

	db, err := postgres.NewConnectDB()
	if err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
	defer db.Close()

	id, err := db.AddSong(song.Song, song.Group, songInfo.Text, songInfo.Link, songInfo.ReleaseDate)
	if err != nil {
		DebugLogger(w, r, err, http.StatusBadRequest)
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(id))
}

//		@Summary		Удаление песни
//		@Tags			song
//		@Description	Удаление песни по id
//		@ID				deleteSong
//		@Accept			json
//		@Produce		json
//		@Param			string	query		string		false	"id"
//		@Success		200		{object}	InfoAddSong	"data"
//		@Failure		400,422	{string}	http.StatusUnprocessableEntity
//		@Failure		500		{string}	http.StatusInternalServerError
//	 	@Router			/song [delete]
func DeleteSong(w http.ResponseWriter, r *http.Request) {
	id := r.URL.Query().Get("id")

	if id == "" {
		DebugLogger(w, r, fmt.Errorf("validation exception"), http.StatusUnprocessableEntity)
	}

	db, err := postgres.NewConnectDB()
	if err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
	defer db.Close()

	song, err := db.DeleteSong(id)
	if err != nil {
		DebugLogger(w, r, err, http.StatusBadRequest)
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(
		Song{
			Id:       song.Id,
			SongName: song.SongName,
			GroupId:  song.GroupId,
			Text:     song.Text,
			Link:     song.Link,
			Date:     song.Date,
		},
	); err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
}

// @Summary		Получение текста песни
// @Tags			song
// @Description	Получение текста песни по куплетам
// @ID			getSong
// @Produce		json
// @Param		id	query		string		false	"id"
// @Param		verseNum	query		int		false	"номер куплета(припев считается куплетом)"
// @Success		200		{object}	VerseSong	"data"
// @Failure		400,422	{string}	http.StatusUnprocessableEntity
// @Failure		500		{string}	http.StatusInternalServerError
// @Router			/song [get]
func GetSong(w http.ResponseWriter, r *http.Request) {
	id := r.URL.Query().Get("id")
	verse := r.URL.Query().Get("verseNum")

	if id == "" {
		DebugLogger(w, r, fmt.Errorf("validation exception"), http.StatusUnprocessableEntity)
	}
	cupletInt, err := strconv.Atoi(verse)
	if err != nil {
		cupletInt = 0
	}

	db, err := postgres.NewConnectDB()
	if err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
	defer db.Close()

	song, err := db.GetSong(id)
	if err != nil {
		DebugLogger(w, r, err, http.StatusBadRequest)
	}

	cuplets := strings.Split(song.Text, "\n\n")
	if cupletInt > len(cuplets) {
		cupletInt = len(cuplets) - 1
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(
		VerseSong{
			Id:     song.Id,
			Verse:  cuplets[cupletInt],
			Verses: len(cuplets),
		},
	); err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
}

// @Summary		Получение списка песен
// @Tags		song
// @Description	Получение текста песни по куплетам
// @ID			getSongs
// @Produce		json
// @Param		page		query		int		false	"страница"
// @Param		volume		query		int		false	"кол-во на одной странице"
// @Param		songName	query		string	false	"имя песни, поиск через ilike"
// @Param		groupId		query		string	false	"поиск по id группы"
// @Param		groupName	query		string	false	"поиск по названию группы, поиск через ilike"
// @Param		text		query		string	false	"текст песни, поиск через ilike"
// @Param		link		query		string	false	"ссылка, поиск через ilike"
// @Param		dateStart	query		string	false	"песни начиная с даты выпуска"
// @Param		dateEnd		query		string	false	"песни до даты выпуска"
// @Success		200		{array}		Song	"список песен"
// @Failure		400,422	{string}	http.StatusUnprocessableEntity
// @Failure		500		{string}	http.StatusInternalServerError
// @Router			/songList [get]
func SongList(w http.ResponseWriter, r *http.Request) {

	page := r.URL.Query().Get("page")
	volume := r.URL.Query().Get("volume")
	songName := r.URL.Query().Get("songName")
	groupId := r.URL.Query().Get("groupId")
	groupName := r.URL.Query().Get("groupName")
	text := r.URL.Query().Get("text")
	link := r.URL.Query().Get("link")
	dateStart := r.URL.Query().Get("dateStart")
	dateEnd := r.URL.Query().Get("dateEnd")

	pageInt, err := strconv.Atoi(page)
	if err != nil {
		pageInt = 1
	}

	volumeInt, err := strconv.Atoi(volume)
	if err != nil {
		volumeInt = 20
	}

	db, err := postgres.NewConnectDB()
	if err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
	defer db.Close()

	songs, err := db.GetSongs(pageInt, volumeInt, postgres.FilterSongList{
		SongName:  songName,
		GroupId:   groupId,
		GroupName: groupName,
		Text:      text,
		Link:      link,
		DateStart: dateStart,
		DateEnd:   dateEnd,
	})
	if err != nil {
		DebugLogger(w, r, err, http.StatusBadRequest)
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	resp := make([]Song, len(songs))
	for i, song := range songs {
		resp[i] = Song{
			Id:       song.Id,
			SongName: song.SongName,
			GroupId:  song.GroupId,
			Text:     song.Text,
			Link:     song.Link,
			Date:     song.Date,
		}
	}

	if err := json.NewEncoder(w).Encode(resp); err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
}

// @Summary		Обновление песни
// @Tags		song
// @Description	Обновление песни
// @ID			updateSong
// @Accept		json
// @Produce		json
// @Param		song	body		Song	true	"песня"
// @Success		200	{object}	Song
// @Failure		400,422	{string}	http.StatusUnprocessableEntity
// @Failure		500		{string}	http.StatusInternalServerError
// @Router			/song [put]

func UpdateSong(w http.ResponseWriter, r *http.Request) {
	var song Song

	if err := json.NewDecoder(r.Body).Decode(&song); err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}

	if song.Id == "" || song.Date == "" || song.Text == "" {
		DebugLogger(w, r, fmt.Errorf("validation exception"), http.StatusUnprocessableEntity)
	}

	db, err := postgres.NewConnectDB()
	if err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
	defer db.Close()

	updatedSong, err := db.UpdateSong(song.Id, song.SongName, song.GroupId, song.Text, song.Link, song.Date)
	if err != nil {
		DebugLogger(w, r, err, http.StatusBadRequest)
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(
		Song{
			Id:       updatedSong.Id,
			SongName: updatedSong.SongName,
			GroupId:  updatedSong.GroupId,
			Text:     updatedSong.Text,
			Link:     updatedSong.Link,
			Date:     updatedSong.Date,
		},
	); err != nil {
		DebugLogger(w, r, err, http.StatusInternalServerError)
	}
}

func RequestSong(group, song string) (*InfoSong, error) {
	address := GetEnv("URL", "https://loaclhost:8080")
	endpoint := GetEnv("INFO", "/info")

	parametrs := url.Values{}
	parametrs.Add("group", group)
	parametrs.Add("song", song)

	u := url.URL{
		Scheme:   "http",
		Host:     address,
		Path:     endpoint,
		RawQuery: parametrs.Encode(),
	}

	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}

	songInfo := InfoSong{}

	if err := json.NewDecoder(resp.Body).Decode(&songInfo); err != nil {
		return nil, err
	}

	return &songInfo, nil
}
